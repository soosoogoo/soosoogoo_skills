
#### 引用笔记
> http://note.youdao.com/noteshare?id=04515ae3c60de6856b215b2dcb4199f5


### MVCC原理

> 通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间(事务ID)，一个保存行的过期时间（或删除时间）。
当然存储的并不是实际的时间值，而是系统版本号（system version number）。
每开始一个新的事务，系统版本号都会自动递增。
事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较.

> http://note.youdao.com/noteshare?id=04515ae3c60de6856b215b2dcb4199f5

#### UPDATE

> InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。



| **user_id** | num  | **create_id** | **delete_id** |
| ----------- | ---- | ------------- | ------------- |
| 1           | 1    | 1             | Null          |
| 2           | 5    | 1             | Null          |
| 3           | 10   | 1             | Null 


#### 执行
```
start transaction;设事务ID=3
update soosoogoo_mvcc set num=111 where user_id=1;
```

#### 结果

| **user_id** | num  | **create_id** | **delete_id** |
| ----------- | ---- | ------------- | ------------- |
| 1           | 1    | 1             | ==3==          |
| 2           | 5    | 1             | Null          |
| 3           | 10   | 1             | Null 
| 1          | 111   | ==3==             | Null 


### 问题:
> 如果 不起事务 , 直接update 是怎样的



### InnoDB会根据以下两个条件检查每行记录: 
>
> 1.InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的. 
> 
> 2.行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除. 

##### ==只有1,2同时满足的记录，才能返回作为查询结果.==


<br/><br/>

#### 图示:

![图片.png](http://note.youdao.com/yws/res/13503/WEBRESOURCE4c365d07fa21e5c156e21c1ec182171e)

<br/><br/>


最后给一个更详细的流程 给闲的蛋疼的人研究

![20180501142804967.png](http://note.youdao.com/yws/res/13508/WEBRESOURCE512f5f6ca9e9ed5f7da3221524718e1f)


<br/><br/>

最后 给好奇大佬们送上 mysql源码地址
> https://github.com/mysql/mysql-server